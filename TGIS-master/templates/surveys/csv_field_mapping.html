{% extends 'base.html' %}
{% load csv_extras %}

{% block extra_css %}
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    .map-preview-container { border: 1px solid #e5e7eb; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.05); position: relative; }
    .map-controls { display: flex; gap: 0.75rem; padding: 0.75rem 1rem; background-color: #f9fafb; border-top: 1px solid #e5e7eb; align-items: center; }
    .map-controls button, .map-controls label { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 8px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; }
    .map-controls button { background-color: #3b82f6; color: white; border: none; }
    .map-controls button.export { background-color: #16a34a; }
    #csv-map { height: 500px; }
    .legend { padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; }
    .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.7; }
    .csv-table-preview { background: #f9fafb; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.04); margin-bottom: 2rem; padding: 1.5rem; }
    .csv-table-preview table { width: 100%; border-collapse: collapse; font-size: 0.95rem; }
    .csv-table-preview th, .csv-table-preview td { border: 1px solid #e5e7eb; padding: 0.5rem 0.75rem; text-align: left; }
    .csv-table-preview th { background: #e0e7ef; font-weight: 600; }
    .csv-table-preview tr:nth-child(even) { background: #f3f4f6; }
    /* Style for permanent labels on map */
    .leaflet-tooltip.permanent-label {
        background-color: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: none;
        color: #333;
        font-weight: bold;
    }
  </style>
{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto mt-10 bg-white rounded-xl shadow-lg p-8 animate-fade-in">
  <h2 class="text-3xl font-bold mb-6 text-gray-800">Map CSV Fields and Preview</h2>
  
  <form method="post" action="" id="field-mapping-form">
    {% csrf_token %}
    
    <div class="mb-6 bg-gray-50 p-6 rounded-lg border">
      <h3 class="text-xl font-semibold mb-4 text-gray-700">1. Map Your Data Fields</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {% for key, label in field_labels.items %}
        <div>
          <label class="block font-medium mb-1 text-gray-600">{{ label }} {% if key == 'kitta_number' %}<span class="text-red-500">*</span>{% endif %}</label>
          <select id="map-{{ key }}" name="map_{{ key }}" class="w-full border rounded p-2 bg-white shadow-sm">
            <option value="">-- Select --</option>
            {% for col in columns %}
              <option value="{{ col }}" {% if field_map|get_item:key == col %}selected{% endif %}>{{ col }}</option>
            {% endfor %}
          </select>
        </div>
        {% endfor %}
      </div>
    </div>

    <div class="csv-table-preview">
      <h3 class="text-lg font-semibold mb-2 text-gray-700 flex items-center justify-between">
        CSV Table Preview (First 10 Rows)
        <span class="flex gap-2">
          <input type="text" id="csv-preview-search" placeholder="Search..." class="border rounded px-2 py-1 text-sm" style="min-width:160px;">
          <button type="button" id="download-preview-csv" class="bg-blue-500 hover:bg-blue-700 text-white font-semibold px-3 py-1 rounded shadow text-sm"><i class="fas fa-download"></i> Download Preview</button>
        </span>
      </h3>
      <div class="overflow-x-auto">
        <table id="csv-preview-table" class="modern-csv-table">
          <thead>
            <tr>
              {% for col in columns %}
                <th data-col="{{ forloop.counter0 }}" class="sortable">{{ col }} <span class="sort-indicator"></span></th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            {% for row in preview_rows %}
              <tr>
                {% for col in columns %}
                  <td>{{ row|get_item:col }}</td>
                {% endfor %}
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
      <div class="flex justify-end items-center gap-2 mt-2" id="csv-preview-pagination"></div>
    </div>
    <style>
      .modern-csv-table th { position: sticky; top: 0; z-index: 2; background: #e0e7ef; box-shadow: 0 2px 4px #e0e7ef44; cursor: pointer; user-select: none; }
      .modern-csv-table th.sortable:hover { background: #c7d2fe; }
      .modern-csv-table th .sort-indicator { font-size: 0.9em; margin-left: 2px; color: #64748b; }
      .modern-csv-table tr:hover { background: #f1f5f9 !important; transition: background 0.2s; }
      .modern-csv-table td, .modern-csv-table th { white-space: nowrap; }
      .modern-csv-table tr:nth-child(even) { background: #f3f4f6; }
      .modern-csv-table { border-radius: 10px; overflow: hidden; }
      #csv-preview-search { outline: none; border: 1px solid #cbd5e1; }
      #csv-preview-search:focus { border-color: #2563eb; box-shadow: 0 0 0 2px #2563eb33; }
      .pagination-btn { background: #e0e7ef; color: #334155; border: none; border-radius: 5px; padding: 3px 10px; margin: 0 2px; font-weight: 600; cursor: pointer; transition: background 0.2s; }
      .pagination-btn.active, .pagination-btn:hover { background: #2563eb; color: #fff; }
    </style>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      // CSV Preview Table Interactivity
      const searchInput = document.getElementById('csv-preview-search');
      const table = document.getElementById('csv-preview-table');
      const tbody = table.tBodies[0];
      const pagination = document.getElementById('csv-preview-pagination');
      let rows = Array.from(tbody.rows);
      let filteredRows = rows.slice();
      let sortCol = null, sortAsc = true;
      const rowsPerPage = 5;
      let currentPage = 1;

      function renderTable() {
        // Filter
        const val = searchInput.value.toLowerCase();
        filteredRows = rows.filter(row => {
          return Array.from(row.cells).some(cell => cell.textContent.toLowerCase().includes(val));
        });
        // Sort
        if (sortCol !== null) {
          filteredRows.sort((a, b) => {
            const aText = a.cells[sortCol].textContent.trim();
            const bText = b.cells[sortCol].textContent.trim();
            if (!isNaN(aText) && !isNaN(bText)) {
              return sortAsc ? (parseFloat(aText) - parseFloat(bText)) : (parseFloat(bText) - parseFloat(aText));
            }
            return sortAsc ? aText.localeCompare(bText) : bText.localeCompare(aText);
          });
        }
        // Pagination
        const totalPages = Math.ceil(filteredRows.length / rowsPerPage) || 1;
        if (currentPage > totalPages) currentPage = totalPages;
        const start = (currentPage - 1) * rowsPerPage;
        const end = start + rowsPerPage;
        Array.from(tbody.rows).forEach(row => row.style.display = 'none');
        filteredRows.slice(start, end).forEach(row => row.style.display = '');
        // Pagination controls
        pagination.innerHTML = '';
        if (totalPages > 1) {
          const prevBtn = document.createElement('button');
          prevBtn.textContent = 'Prev';
          prevBtn.className = 'pagination-btn';
          prevBtn.disabled = currentPage === 1;
          prevBtn.onclick = () => { currentPage--; renderTable(); };
          pagination.appendChild(prevBtn);
          for (let i = 1; i <= totalPages; i++) {
            const btn = document.createElement('button');
            btn.textContent = i;
            btn.className = 'pagination-btn' + (i === currentPage ? ' active' : '');
            btn.onclick = () => { currentPage = i; renderTable(); };
            pagination.appendChild(btn);
          }
          const nextBtn = document.createElement('button');
          nextBtn.textContent = 'Next';
          nextBtn.className = 'pagination-btn';
          nextBtn.disabled = currentPage === totalPages;
          nextBtn.onclick = () => { currentPage++; renderTable(); };
          pagination.appendChild(nextBtn);
        }
        // Update sort indicators
        table.querySelectorAll('th').forEach((th, idx) => {
          const indicator = th.querySelector('.sort-indicator');
          if (sortCol === idx) {
            indicator.textContent = sortAsc ? '▲' : '▼';
          } else {
            indicator.textContent = '';
          }
        });
      }
      // Search
      searchInput.addEventListener('input', function() { currentPage = 1; renderTable(); });
      // Sorting
      table.querySelectorAll('th.sortable').forEach((th, idx) => {
        th.addEventListener('click', function() {
          if (sortCol === idx) { sortAsc = !sortAsc; } else { sortCol = idx; sortAsc = true; }
          renderTable();
        });
      });
      // Download Preview as CSV
      document.getElementById('download-preview-csv').addEventListener('click', function() {
        let csv = '';
        const visibleRows = filteredRows.slice((currentPage-1)*rowsPerPage, (currentPage)*rowsPerPage);
        const headerCells = table.querySelectorAll('thead th');
        csv += Array.from(headerCells).map(cell => '"' + cell.textContent.replace(/"/g, '""') + '"').join(',') + '\n';
        for (const row of visibleRows) {
          const cells = row.querySelectorAll('td');
          const rowStr = Array.from(cells).map(cell => '"' + cell.textContent.replace(/"/g, '""') + '"').join(',');
          csv += rowStr + '\n';
        }
        const blob = new Blob([csv], {type: 'text/csv'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'csv_preview.csv';
        link.click();
      });
      // Initial render
      renderTable();
    });
    </script>

    <div class="mb-6 bg-gray-50 p-6 rounded-lg border">
        <h3 class="text-xl font-semibold mb-2 text-gray-700">2. Preview Data on Map</h3>
        <div class="map-preview-container">
            <div id="csv-map"></div>
            <div class="map-controls">
                <label title="Toggle visibility of point markers"><input type="checkbox" id="toggle-points" checked> Show Points</label>
                <button type="button" id="zoom-fit" title="Zoom to all visible points/polygons"><i class="fas fa-search-plus"></i> Zoom to Fit</button>
                <button type="button" id="export-map" class="export" title="Export current map view as PNG image"><i class="fas fa-camera"></i> Export as Image</button>
            </div>
        </div>
    </div>
    
    <div class="flex flex-col md:flex-row gap-4" style="z-index: 100; position: relative;">
      <button type="submit" name="action" value="confirm" class="w-full py-3 px-4 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 flex-1">
        <i class="fas fa-check-circle"></i> Confirm Mapping & Continue
      </button>
      <button type="submit" name="action" value="download_kml" class="w-full py-3 px-4 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 flex-1">
        <i class="fas fa-download"></i> Download as KML
      </button>
    </div>
  </form>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-image@0.4.0/dist/leaflet-image.js"></script>
{{ preview_rows|json_script:"preview-rows-data" }}

<script>
document.addEventListener('DOMContentLoaded', function() {
  try { // Add a top-level try-catch to prevent any errors from breaking the page
    const previewRows = JSON.parse(document.getElementById('preview-rows-data').textContent);
    let map, pointLayer, shapeLayer, bounds, legend;
    const shapeColors = ['#e41a1c', '#4daf4a', '#984ea3', '#ff7f00', '#377eb8'];
    let shapeIndex = 0;

    function initMap() {
        if (map) return;
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '© Esri', crossOrigin: 'anonymous' });
        const street = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap', crossOrigin: 'anonymous' });
        map = L.map('csv-map', { layers: [satellite] }).setView([27.7, 85.3], 8);
        L.control.layers({ "Satellite": satellite, "Street": street }).addTo(map);
        pointLayer = L.layerGroup().addTo(map);
        shapeLayer = L.layerGroup().addTo(map);
        legend = L.control({position: 'bottomright'});
        legend.onAdd = function (map) { return L.DomUtil.create('div', 'info legend'); };
        legend.addTo(map);
    }

    function updateMap() {
        pointLayer.clearLayers();
        shapeLayer.clearLayers();
        bounds = L.latLngBounds();
        shapeIndex = 0;

        const latCol = document.getElementById('map-lat').value;
        const lonCol = document.getElementById('map-lon').value;
        const geomCol = document.getElementById('map-geometry').value;
        const nameCol = Object.keys(previewRows[0] || {}).find(k => k.toLowerCase() === 'name' || k.toLowerCase() === 'label');

        previewRows.forEach(row => {
          try { // Add try-catch for each row to handle bad data gracefully
            // Draw points only if lat and lon columns are selected and valid
            if (latCol && lonCol) {
                const lat = parseFloat(row[latCol]);
                const lon = parseFloat(row[lonCol]);
                if (!isNaN(lat) && !isNaN(lon)) {
                    const marker = L.circleMarker([lat, lon], { radius: 5, color: '#3388ff', fillOpacity: 0.8 });
                    pointLayer.addLayer(marker);
                    bounds.extend([lat, lon]);
                }
            }
            
            // Draw shapes only if geometry column is selected and valid
            if (geomCol && row[geomCol]) {
                const layer = parseGeometry(row[geomCol]);
                if (layer) {
                    const color = shapeColors[shapeIndex % shapeColors.length];
                    layer.setStyle({ color: color, weight: 3, opacity: 1, fillOpacity: 0.2 });
                    if (nameCol && row[nameCol]) {
                        layer.bindTooltip(String(row[nameCol]), { permanent: true, direction: 'center', className: 'permanent-label' });
                    }
                    shapeLayer.addLayer(layer);
                    bounds.extend(layer.getBounds());
                    shapeIndex++;
                }
            }
          } catch(e) {
            console.error("Could not process row:", row, e);
          }
        });
        
        if (bounds.isValid()) map.fitBounds(bounds, { padding: [50, 50], maxZoom: 18 });
    }

    function parseGeometry(geomString) {
        if (typeof geomString !== 'string' || !geomString.length) return null;
        try { 
            const geojson = JSON.parse(geomString);
            if (geojson.type && geojson.coordinates) return L.geoJSON(geojson);
        } catch (e) { /* Fallback to WKT */ }
        
        const str = geomString.toUpperCase().trim();
        let coords;
        if (str.startsWith('POLYGON')) {
            const match = str.match(/\(\((.*)\)\)/);
            if (match && match[1]) {
                coords = match[1].split(',').map(p => p.trim().split(/\s+/).map(Number).reverse());
                return L.polygon(coords);
            }
        }
        if (str.startsWith('LINESTRING')) {
            const match = str.match(/\((.*)\)/);
            if (match && match[1]) {
                coords = match[1].split(',').map(p => p.trim().split(/\s+/).map(Number).reverse());
                return L.polyline(coords);
            }
        }
        return null;
    }

    // --- EVENT LISTENERS for controls ---
    document.querySelectorAll('select').forEach(select => select.addEventListener('change', updateMap));
    const togglePoints = document.getElementById('toggle-points');
    const zoomFitBtn = document.getElementById('zoom-fit');
    const exportMapBtn = document.getElementById('export-map');
    function isMapReady() { return typeof map !== 'undefined' && map && pointLayer && shapeLayer; }
    togglePoints.addEventListener('change', e => {
      if (!isMapReady()) { alert('Map is not ready. Please wait.'); e.target.checked = true; return; }
      if (e.target.checked) map.addLayer(pointLayer);
      else map.removeLayer(pointLayer);
    });
    zoomFitBtn.addEventListener('click', () => {
      if (!isMapReady()) { alert('Map is not ready. Please wait.'); return; }
      if (bounds && bounds.isValid()) map.fitBounds(bounds, { padding: [50, 50], maxZoom: 18 });
      else alert('No points or polygons to fit.');
    });
    exportMapBtn.addEventListener('click', () => {
      if (!isMapReady()) { alert('Map is not ready. Please wait.'); return; }
      exportMapBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Exporting...';
      exportMapBtn.disabled = true;
      leafletImage(map, function(err, canvas) {
        if (err) {
          alert('Could not export map. The tile server may be blocking the request or CORS is not allowed. Try a different map layer.');
          console.error('Leaflet-image error:', err);
          exportMapBtn.innerHTML = '<i class="fas fa-camera"></i> Export as Image';
          exportMapBtn.disabled = false;
          return;
        }
        const link = document.createElement('a');
        link.download = 'map-preview.png';
        link.href = canvas.toDataURL();
        link.click();
        exportMapBtn.innerHTML = '<i class="fas fa-camera"></i> Export as Image';
        exportMapBtn.disabled = false;
      });
    });
    // Optionally, disable Export/Zoom if no points
    function updateMapControls() {
      const hasPoints = pointLayer && pointLayer.getLayers && pointLayer.getLayers().length > 0;
      zoomFitBtn.disabled = !hasPoints;
      exportMapBtn.disabled = !hasPoints;
    }
    // Call after each map update
    const origUpdateMap = updateMap;
    updateMap = function() { origUpdateMap(); updateMapControls(); };
    // Initial state
    updateMapControls();
  } catch (e) {
    console.error("A critical error occurred on the mapping page:", e);
    alert("An error occurred while initializing the map preview. Some features may not work correctly.");
  }
});
</script>
{% endblock %} 